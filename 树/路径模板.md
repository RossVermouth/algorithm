## 二叉树的所有路径

dfs 求路径，每访问到一个结点就把它加到路径中，当来到叶子的时候收集路径结果。  

边界：空树时返回{}  

```java
    // O(n) O(n)
    public List<List<Integer>> binaryTreePaths(TreeNode root) {
        List<List<Integer>>  paths = new ArrayList<>();
        if (root == null) {
            return paths;
        }
        List<Integer> path = new ArrayList<>();
        backtrace(root, path, paths);
        return paths;
    }
    // 在以root为根的树中收集路径并将结果追加到path后，最终paths中存放的就是所有路径
    private void backtrace(TreeNode root, List<Integer> path, List<List<Integer>> paths) {
        path.add(root.val);
        if (root.left == null && root.right == null) {
            // 收集结果，将路径的拷贝加入结果集
            paths.add(new ArrayList<>(path));
            return;
        }
        if (root.left != null) {
            backtrace(root.left, path, paths);
        }
        if (root.right != null) {
            backtrace(root.right, path, paths);
        }
    }
```

## 扩展点

## 多叉树中以 p 结尾的和为 targetSum 的所有路径

测例：  
![](https://github.com/RossVermouth/algorithm/blob/main/%E9%99%84%E4%BB%B6/%E8%B7%AF%E5%BE%84%E5%92%8C.png)

```java
package leetcode.multipath;

import java.util.ArrayList;
import java.util.List;

public class Solution {
    // 求多叉树中以 p 结点结尾的和为 targetSum 的所有路径
    public List<List<Integer>> getPaths(Node root, Node p, int targetSum) {
        List<List<Integer>> paths = new ArrayList<>();
        if (root == null || p == null) {
            return paths;
        }
        List<Integer> path = new ArrayList<>();
        backtrace(root, p, 0, targetSum, path, paths);
        return paths;
    }
    // 从root开始找终点为p且累加和是targetSum的所有路径
    private void backtrace(Node root, Node p, int curSum, int targetSum,
                            List<Integer> path, List<List<Integer>> paths) {
        curSum += root.val;
        path.add(root.val);
        if (root == p && curSum == targetSum) {
            paths.add(new ArrayList<>(path));
            return;
        }
        for (Node child: root.children) {
            backtrace(child, p, curSum, targetSum, path, paths);
            path.remove(path.size() - 1);
        }
    }


    // dfs print tree for test
    private void printTree(Node root) {
        if (root == null) {
            return;
        }
        String res = root.val + " : ";
        for (Node child: root.children) {
            res += child.val + " ";
        }
        System.out.println(res);
        for (Node child: root.children) {
            printTree(child);
        }
    }

    public static void main(String[] args) {
        Node node1 = new Node(1, new ArrayList<>());
        Node node2 = new Node(2, new ArrayList<>());
        Node node3 = new Node(3, new ArrayList<>());
        Node node4 = new Node(4, new ArrayList<>());
        Node node5 = new Node(5, new ArrayList<>());
        Node node6 = new Node(6, new ArrayList<>());
        Node node7 = new Node(7, new ArrayList<>());
        Node node8 = new Node(8, new ArrayList<>());
        Node node9 = new Node(16, new ArrayList<>());
        Node node10 = new Node(13, new ArrayList<>());
        node1.children.add(node2);
        node1.children.add(node3);
        node2.children.add(node4);
        node2.children.add(node5);
        node2.children.add(node6);
        node3.children.add(node7);
        node3.children.add(node8);
        node5.children.add(node9);
        node7.children.add(node10);
        Solution solution = new Solution();
        System.out.println("树结构:");
        solution.printTree(node1);
        List<List<Integer>> res = solution.getPaths(node1, node9, 24);
        System.out.println("路径集:");
        for (int i = 0; i < res.size(); i++) {
            System.out.print("第" + i + "条路径:");
            for (int j = 0; j < res.get(i).size(); j++) {
                System.out.print(res.get(i).get(j) + " ");
            }
            System.out.println();
        }
    }
}

class Node {
    int val;
    List<Node> children;
    public Node() {}
    public Node(int val) {
        this.val = val;
    }
    public Node(int val, List<Node> children) {
        this.val = val;
        this.children = children;
    }
}
```
