## 题目链接

[leetcode 139](https://leetcode.cn/problems/word-break/)  

## 题目描述 

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。  

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。  

1 <= s.length <= 300  
1 <= wordDict.length <= 1000  

```html
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
      注意，你可以重复使用字典中的单词。

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

## 解题思路  

- 状态函数
  - 设 dp[i] 表示 s[0, i] 区间子串是否可以有 wd 中的单次拼接出
  - 自变量范围 0 <= i <= n - 1， n 为 s 的长度
  - 目标求 dp[n - 1]
- 转移方程
  - dp[i] =  dp[i] | (s[0, i].endsWith(word) && (i + 1 == word.length() || dp[i - word.length()]))， iter for all words
  - 转移方程自变量范围 i >= 0
- 边界值及鲁棒性
  - n >= 1 走转移方程
- 空间压缩
  - dp[i] 依赖 dp[0] ~ dp[i - 1] ，无法压缩空间


```java
class Solution {
    // O(n * m * word.len) O(n), n是s长度, m是词个数
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        // dp[i]为使用wordDict中的词能否拼出s[0, i]子串
        boolean[] dp = new boolean[n];
        // 扫描所有区间
        for (int i = 0; i < n; i++) {
            String str = s.substring(0, i + 1);
            // 当前区间的单次是否可以使用wd中的单次作为尾缀，如果可以，那么 1.消费完 2.剩余部分可以构造都可以使[0, i] 区间可构造
            for (String word: wordDict) {
                dp[i] = dp[i] || (str.endsWith(word) && (i + 1 == word.length() || dp[i - word.length()]));
            }
        }
        return dp[n - 1];
    }
}
```



